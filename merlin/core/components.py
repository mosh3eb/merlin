"""
Pure descriptive components that describe WHAT we want, not HOW to implement it.
Components are platform-agnostic and focus on intent rather than implementation.
"""

from dataclasses import dataclass
from typing import Optional, Union, List, Any, Dict
from enum import Enum


class ParameterRole(Enum):
    """Clear role definition for parameters."""
    FIXED = "fixed"  # Fixed value, not a parameter
    INPUT = "input"  # Input parameter (fed from data)
    TRAINABLE = "trainable"  # Trainable parameter (nn.Parameter)


@dataclass
class Rotation:
    """
    Rotation gate description.

    The actual parameter name will be generated by the backend based on role.
    """
    target: int
    role: ParameterRole = ParameterRole.FIXED
    value: float = 0.0  # Used when role=FIXED
    axis: str = "z"

    # Optional: let user specify custom name if they want
    custom_name: Optional[str] = None

    def get_params(self) -> Dict[str, Any]:
        """Get parameters (for compatibility)."""
        if self.custom_name and self.role != ParameterRole.FIXED:
            return {self.custom_name: self.value if self.role == ParameterRole.FIXED else None}
        return {}


@dataclass
class BeamSplitter:
    """Beam splitter description."""
    targets: tuple
    theta_role: ParameterRole = ParameterRole.FIXED
    theta_value: float = 0.7854  # pi/4 default
    phi_role: ParameterRole = ParameterRole.FIXED
    phi_value: float = 0.0

    # Optional custom names
    theta_name: Optional[str] = None
    phi_name: Optional[str] = None

    def get_params(self) -> Dict[str, Any]:
        """Get parameters (for compatibility)."""
        params = {}
        if self.theta_name and self.theta_role != ParameterRole.FIXED:
            params[self.theta_name] = None
        if self.phi_name and self.phi_role != ParameterRole.FIXED:
            params[self.phi_name] = None
        return params


@dataclass
class EntanglingBlock:
    """Entangling block description."""
    targets: Union[str, List[int]] = "all"
    pattern: str = "nearest_neighbor"
    depth: int = 1
    trainable: bool = True
    name_prefix: Optional[str] = None

    def get_params(self) -> Dict[str, Any]:
        """Get parameters (for compatibility)."""
        return {}


@dataclass
class Measurement:
    """Measurement description."""
    targets: List[int]
    basis: str = "computational"

    def get_params(self) -> Dict[str, Any]:
        """Get parameters (for compatibility)."""
        return {}


# For backward compatibility, keep old interface but map to new
class Component:
    """Base class for backward compatibility."""
    pass


# Adapter for old-style components
def adapt_old_rotation(
        target: int,
        angle: Union[float, str, None] = None,
        axis: str = "z",
        trainable: Optional[bool] = False,
        as_input: Optional[bool] = False,
        value: Optional[float] = None,
) -> Rotation:
    """Adapt old-style rotation to new format."""
    # Determine role from old flags
    if as_input:
        role = ParameterRole.INPUT
    elif trainable:
        role = ParameterRole.TRAINABLE
    else:
        role = ParameterRole.FIXED

    # Determine value and name
    if isinstance(angle, str):
        custom_name = angle
        final_value = value if value is not None else 0.0
    elif angle is not None:
        custom_name = None
        final_value = float(angle)
    else:
        custom_name = None
        final_value = value if value is not None else 0.0

    return Rotation(
        target=target,
        role=role,
        value=final_value,
        axis=axis,
        custom_name=custom_name
    )