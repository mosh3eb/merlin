"""
Pure descriptive components that describe WHAT we want, not HOW to implement it.
Components are platform-agnostic and focus on intent rather than implementation.
"""

from dataclasses import dataclass
from typing import Optional, Union, List, Any, Dict
from enum import Enum


class ParameterRole(Enum):
    """Clear role definition for parameters."""
    FIXED = "fixed"  # Fixed value, not a parameter
    INPUT = "input"  # Input parameter (fed from data)
    TRAINABLE = "trainable"  # Trainable parameter (nn.Parameter)


@dataclass
class Rotation:
    """
    Rotation gate description.

    The actual parameter name will be generated by the backend based on role.
    """
    target: int
    role: ParameterRole = ParameterRole.FIXED
    value: float = 0.0  # Used when role=FIXED
    axis: str = "z"

    # Optional: let user specify custom name if they want
    custom_name: Optional[str] = None

    def get_params(self) -> Dict[str, Any]:
        """Return declared parameter placeholders for the rotation.

        Non-fixed rotations expose either their custom name or the automatically
        generated identifier so that downstream tooling can bind data or trainable
        tensors to the gate.

        Returns:
            Dict[str, Any]: Mapping from parameter name to placeholder value.
        """
        if self.custom_name and self.role != ParameterRole.FIXED:
            return {self.custom_name: self.value if self.role == ParameterRole.FIXED else None}
        return {}


@dataclass
class BeamSplitter:
    """Beam splitter description."""
    targets: tuple
    theta_role: ParameterRole = ParameterRole.FIXED
    theta_value: float = 0.7854  # pi/4 default
    phi_role: ParameterRole = ParameterRole.FIXED
    phi_value: float = 0.0

    # Optional custom names
    theta_name: Optional[str] = None
    phi_name: Optional[str] = None

    def get_params(self) -> Dict[str, Any]:
        """Describe which phase shifter angles should be exposed as parameters.

        Returns:
            Dict[str, Any]: Parameter placeholders keyed by their symbolic names.
        """
        params = {}
        if self.theta_name and self.theta_role != ParameterRole.FIXED:
            params[self.theta_name] = None
        if self.phi_name and self.phi_role != ParameterRole.FIXED:
            params[self.phi_name] = None
        return params


@dataclass
class EntanglingBlock:
    """Entangling block description."""
    targets: Union[str, List[int]] = "all"
    pattern: str = "nearest_neighbor"
    depth: int = 1
    trainable: bool = True
    name_prefix: Optional[str] = None

    def get_params(self) -> Dict[str, Any]:
        """Entangling blocks themselves carry no direct parameters.

        Returns:
            Dict[str, Any]: Always empty because entangling blocks are metadata-only.
        """
        return {}


@dataclass
class GenericInterferometer:
    """Generic interferometer block spanning multiple modes."""

    start_mode: int
    span: int
    trainable: bool = True
    name_prefix: Optional[str] = None

    def get_params(self) -> Dict[str, Any]:
        """Return placeholder names for every internal interferometer parameter.

        Returns:
            Dict[str, Any]: Mapping of generated parameter names to ``None`` placeholders.
        """
        if not self.trainable or self.span < 2:
            return {}

        prefix = self.name_prefix or "gi"
        count = self.span * (self.span - 1) // 2
        params: Dict[str, Any] = {}
        for idx in range(count):
            params[f"{prefix}_li{idx}"] = None
            params[f"{prefix}_lo{idx}"] = None
        return params


@dataclass
class Measurement:
    """Measurement description."""
    targets: List[int]
    basis: str = "computational"

    def get_params(self) -> Dict[str, Any]:
        """Measurements are descriptive only and expose no tunable parameters.

        Returns:
            Dict[str, Any]: Always empty because measurements introduce no parameters.
        """
        return {}


# For backward compatibility, keep old interface but map to new
class Component:
    """Base class for backward compatibility."""
    pass


# Adapter for old-style components
def adapt_old_rotation(
        target: int,
        angle: Union[float, str, None] = None,
        axis: str = "z",
        trainable: Optional[bool] = False,
        as_input: Optional[bool] = False,
        value: Optional[float] = None,
) -> Rotation:
    """Translate legacy rotation arguments into the structured :class:`Rotation`.

    Args:
        target: Circuit mode acted on by the rotation.
        angle: Either a literal rotation angle or the legacy symbolic name.
        axis: Axis of rotation in the Bloch sphere convention.
        trainable: Whether the rotation should be promoted to a trainable parameter.
        as_input: Whether the rotation angle should be provided by data at runtime.
        value: Optional fallback numeric value when ``angle`` is symbolic or omitted.

    Returns:
        Rotation: Dataclass describing the rotation with updated naming semantics.
    """
    # Determine role from old flags
    if as_input:
        role = ParameterRole.INPUT
    elif trainable:
        role = ParameterRole.TRAINABLE
    else:
        role = ParameterRole.FIXED

    # Determine value and name
    if isinstance(angle, str):
        custom_name = angle
        final_value = value if value is not None else 0.0
    elif angle is not None:
        custom_name = None
        final_value = float(angle)
    else:
        custom_name = None
        final_value = value if value is not None else 0.0

    return Rotation(
        target=target,
        role=role,
        value=final_value,
        axis=axis,
        custom_name=custom_name
    )
