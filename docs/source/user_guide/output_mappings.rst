:github_url: https://github.com/merlinquantum/merlin

=========================
Output Measurement Guide
=========================

Merlin now exposes quantum-to-classical conversion through two orthogonal concepts:

- :class:`~merlin.measurement.strategies.MeasurementStrategy` selects how results are extracted from the quantum simulation or hardware backend.
- :class:`~merlin.utils.grouping.mappers.LexGrouping` and :class:`~merlin.utils.grouping.mappers.ModGrouping` provide optional post-processing of outputs.

The legacy output mapping strategy enum has been removed. This page explains how to build measurement pipelines with the new API.

Measurement Strategies
======================

MEASUREMENTDISTRIBUTION
-----------------------

Produces the probability of observing each Fock state. If the simulation returns amplitudes, Merlin turns them into probabilities via :math:`|a|^2`.

.. code-block:: python

    ansatz = ML.AnsatzFactory.create(
        PhotonicBackend=experiment,
        input_size=4,
        measurement_strategy=ML.MeasurementStrategy.MEASUREMENTDISTRIBUTION,
    )
    quantum_layer = ML.QuantumLayer(input_size=4, ansatz=ansatz)

The underlying PyTorch module is :class:`~merlin.measurement.mappers.MeasurementDistribution`.
Characteristics:

- Output shape matches the number of Fock states generated by the experiment.
- Values are real, non-negative, and sum to one.
- Ideal when classical code consumes the raw quantum probability distribution.

Extensions:

- Add ``torch.nn.Linear`` or any classical layer after the quantum layer to map the probabilities to logits/regression targets.
- Combine with :class:`~merlin.utils.grouping.mappers.LexGrouping` or :class:`~merlin.utils.grouping.mappers.ModGrouping` when you need fewer output features and don't want to increase the number of parameters.

MODEEXPECTATIONS
----------------

Marginalises the Fock distribution to per-mode statistics. Provide the list of accessible Fock states (``keys``) to initialise the mapper once, then feed batches of amplitudes or probabilities.

.. code-block:: python

    keys = [(1, 0, 1, 0), (0, 2, 0, 0), (0, 1, 0, 1)]
    ansatz = ML.AnsatzFactory.create(
        PhotonicBackend=experiment,
        input_size=2,
        measurement_strategy=ML.MeasurementStrategy.MODEEXPECTATIONS,
        no_bunching=True,  # Return per-mode “probability of at least one photon”
    )

Use :class:`~merlin.measurement.mappers.ModeExpectations` when working directly with the mapper.
Key properties:

- ``no_bunching=True`` (default) reports occupancy probabilities per mode.
- ``no_bunching=False`` returns the expected photon count per mode.
- Output size always equals the number of modes implied by ``keys``.

AMPLITUDEVECTOR
---------------

Returns the complex amplitudes directly. This strategy is only meaningful in simulation, because amplitudes cannot be measured or obtained on hardware.

.. code-block:: python

    ansatz = ML.AnsatzFactory.create(
        PhotonicBackend=experiment,
        input_size=3,
        measurement_strategy=ML.MeasurementStrategy.AMPLITUDEVECTOR,
    )

Use this strategy for debugging, algorithmic research, or when a classical routine manipulates complex amplitudes directly. The output is a complex tensor normalised to unit norm (within numerical precision).

The helper module is :class:`~merlin.measurement.mappers.AmplitudeVector`.

CUSTOMOBSERVABLE
----------------

Placeholder for future support of user-defined observables. Instantiating the strategy currently returns a stub module that echoes its input.

Grouping Modules
================

Grouping modules reshape the output of :class:`~merlin.measurement.strategies.MeasurementStrategy.MEASUREMENTDISTRIBUTION` into smaller feature sets while preserving differentiability.

LexGrouping
-----------

Groups consecutive values into equally sized buckets. Padding with zeros ensures all buckets have the same width.

.. code-block:: python

    quantum = ML.QuantumLayer(input_size=4, ansatz=ansatz)
    grouped = nn.Sequential(
        quantum,
        ML.LexGrouping(input_size=quantum.output_size, output_size=8),
    )

Useful when the order of Fock states carries meaning (e.g., lexicographic encoding). The module preserves probability mass and supports batched inputs.

Example (single vector)::

    >>> p = torch.tensor([0.1, 0.2, 0.4, 0.3])
    >>> mapper = ML.LexGrouping(input_size=4, output_size=2)
    >>> mapper(p)
    tensor([0.3000, 0.7000])

ModGrouping
-----------

Sums values sharing the same index modulo ``output_size``. When ``output_size`` exceeds ``input_size``, the layer pads with zeros.

.. code-block:: python

    grouped = nn.Sequential(
        quantum,
        ML.ModGrouping(input_size=quantum.output_size, output_size=6),
    )

This is effective for cyclic structures (e.g., periodic sensors) where indices wrapping around the distribution should be combined.

Example (single vector)::

    >>> p = torch.tensor([0.1, 0.2, 0.3, 0.4])
    >>> mapper = ML.ModGrouping(input_size=4, output_size=2)
    >>> mapper(p)
    tensor([0.4000, 0.6000])

Chaining Measurement and Grouping
---------------------------------

.. code-block:: python

    import torch.nn as nn

    experiment = ML.PhotonicBackend(
        circuit_type=ML.CircuitType.PARALLEL_COLUMNS,
        n_modes=4,
        n_photons=2,
    )

    ansatz = ML.AnsatzFactory.create(
        PhotonicBackend=experiment,
        input_size=2,
        measurement_strategy=ML.MeasurementStrategy.MEASUREMENTDISTRIBUTION,
    )

    quantum_layer = ML.QuantumLayer(input_size=2, ansatz=ansatz)

    quantum_pipeline = nn.Sequential(
        quantum_layer,
        ML.ModGrouping(input_size=quantum_layer.output_size, output_size=3),
        nn.Linear(3, 1),
    )

Migrating from OutputMappingStrategy
====================================

Legacy name → new pipeline:

- ``OutputMappingStrategy.NONE`` → ``MeasurementStrategy.MEASUREMENTDISTRIBUTION``
- ``OutputMappingStrategy.LINEAR`` → ``MeasurementStrategy.MEASUREMENTDISTRIBUTION`` followed by a torch.nn.Linear layer
- ``OutputMappingStrategy.LEXGROUPING`` or ``GROUPING`` → ``MeasurementStrategy.MEASUREMENTDISTRIBUTION`` + :class:`~merlin.utils.grouping.mappers.LexGrouping`
- ``OutputMappingStrategy.MODGROUPING`` → ``MeasurementStrategy.MEASUREMENTDISTRIBUTION`` + :class:`~merlin.utils.grouping.mappers.ModGrouping`

Selection Cheat Sheet
=====================

.. list-table::
   :header-rows: 1
   :widths: 25 35 40

   * - Scenario
     - Recommended Pipeline
     - Notes
   * - Classification / Regression
     - ``MEASUREMENTDISTRIBUTION`` + classical head
     - Obtain logits or arbitrary ranges with ``nn.Linear`` or deeper networks.
   * - Structured probability outputs
     - ``MEASUREMENTDISTRIBUTION`` + ``LexGrouping`` / ``ModGrouping``
     - Preserves probability mass while reducing dimensionality.
   * - Hardware-friendly analytics
     - ``MODEEXPECTATIONS`` (``no_bunching`` to taste)
     - Outputs one feature per mode, easy to interpret.
   * - Algorithm debugging
     - ``AMPLITUDEVECTOR``
     - Complex amplitudes, simulation only.

Validation Tips
===============

- :class:`~merlin.measurement.mappers.MeasurementDistribution` automatically detects whether inputs are amplitudes or probabilities by checking the :math:`\ell_2` norm.
- :class:`~merlin.measurement.mappers.ModeExpectations` stores the marginalisation mask as a buffer, so it moves with the model across devices.
- ``LexGrouping`` and ``ModGrouping`` are differentiable and keep gradients flowing back to the quantum layer.
