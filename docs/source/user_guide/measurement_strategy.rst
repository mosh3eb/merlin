:github_url: https://github.com/merlinquantum/merlin

==========================
Measurement Strategy Guide
==========================

Merlin now exposes quantum-to-classical conversion through two orthogonal concepts:

- :class:`~merlin.measurement.strategies.MeasurementStrategy` selects how results are extracted from the quantum simulation or hardware backend.
- :class:`~merlin.utils.grouping.LexGrouping` and :class:`~merlin.utils.grouping.ModGrouping` provide optional post-processing of outputs (see :doc:`./grouping`).

Detector-aware execution
========================

When a :class:`perceval.Experiment` is provided, the :class:`~merlin.algorithms.layer.QuantumLayer`
derives a detector transform that remaps raw Fock-state probabilities to the classical
outcomes defined by the experiment. This detector mapping is applied **before** the
measurement strategy converts the distribution into classical features. As a consequence:

* ``MeasurementStrategy.PROBABILITIES`` and ``MeasurementStrategy.MODE_EXPECTATIONS`` transparently work with any detector setup.
* ``MeasurementStrategy.AMPLITUDES`` requires direct access to the complex amplitudes and therefore **cannot** be used when custom detectors are defined (the layer will raise a ``RuntimeError``).

The sections below describe each strategy assuming detector support is valid for that choice.

PROBABILITIES
-----------------------

Produces the probability of observing each Fock state. If the simulation returns amplitudes, Merlin turns them into probabilities via :math:`|a|^2`.

.. code-block:: python

    builder = CircuitBuilder(n_modes=5)
    # Add whatever to your builder

    quantum_layer = QuantumLayer(.
        input_size=4,
        builder=builder,
        n_photons=2,
        measurement_strategy=MeasurementStrategy.PROBABILITIES,  # Optional because this is its default value
    )

The underlying PyTorch module is :class:`~merlin.measurement.mappers.Probabilities`.
Characteristics:

- Output shape matches the number of Fock states generated by the experiment.
- Values are real, non-negative, and sum to one.
- Ideal when classical code consumes the raw quantum probability distribution.

Extensions:

- Add ``torch.nn.Linear`` or any classical layer after the quantum layer to map the probabilities to logits/regression targets.
- Combine with :class:`~merlin.utils.grouping.LexGrouping` or :class:`~merlin.utils.grouping.ModGrouping` when you need fewer output features and don't want to increase the number of parameters.

MODE_EXPECTATIONS
----------------

Marginalises the Fock distribution to per-mode expectation values.

.. code-block:: python

    builder = CircuitBuilder(n_modes=5)
    # Add whatever to your builder

    quantum_layer = QuantumLayer(.
        input_size=4,
        builder=builder,
        n_photons=2,
        measurement_strategy=MeasurementStrategy.MODE_EXPECTATIONS,
    )

Use :class:`~merlin.measurement.mappers.ModeExpectations` when working directly with the mapper.
Key properties:

- ``no_bunching=True`` (default) reports occupancy probabilities per mode.
- ``no_bunching=False`` returns the expected photon count per mode.
- Output size always equals the number of modes.

AMPLITUDES
---------------

Returns the complex amplitudes directly. This strategy is only meaningful in 
simulation, because amplitudes cannot be measured or obtained on hardware. Indeed,
returning amplitudes is physically non-realizable and should mainly be used for 
connecting two quantum layers (e.g. when the second one uses amplitude encoding) 
or for analytical purposes when studying quantum systems.

Adding detectors corresponds to performing a measurement of the quantum state, 
which collapses it and is therefore incompatible with amplitude retrieval. Thus,
this measurement strategy **requires that no detectors are defined**.

.. code-block:: python

    builder = CircuitBuilder(n_modes=5)
    # Add whatever to your builder

    quantum_layer = QuantumLayer(.
        input_size=4,
        builder=builder,
        n_photons=2,
        measurement_strategy=MeasurementStrategy.AMPLITUDES,
    )

Use this strategy for debugging, algorithmic research, or when a classical routine manipulates complex amplitudes directly. The output is a complex tensor normalised to unit norm (within numerical precision). Attempting to combine ``MeasurementStrategy.AMPLITUDES`` with custom detectors raises a ``RuntimeError``.

The helper module is :class:`~merlin.measurement.mappers.Amplitudes`.

Migrating from OutputMappingStrategy (legacy)
============================================

Earlier releases exposed :class:`~merlin.algorithms.layer.QuantumLayer` through
``OutputMappingStrategy``. Newc code should rely on :class:`~merlin.measurement.strategies.MeasurementStrategy`
instead. The mapping is:

- ``OutputMappingStrategy.NONE`` → ``MeasurementStrategy.PROBABILITIES``
- ``OutputMappingStrategy.LINEAR`` → ``MeasurementStrategy.PROBABILITIES`` followed by a ``torch.nn.Linear`` layer
- ``OutputMappingStrategy.LEXGROUPING`` or ``GROUPING`` → ``MeasurementStrategy.PROBABILITIES`` + :class:`~merlin.utils.grouping.LexGrouping`
- ``OutputMappingStrategy.MODGROUPING`` → ``MeasurementStrategy.PROBABILITIES`` + :class:`~merlin.utils.grouping.ModGrouping`

Selection Cheat Sheet
=====================

.. list-table::
   :header-rows: 1
   :widths: 25 35 40

   * - Scenario
     - Recommended Pipeline
     - Notes
   * - Classification / Regression
     - ``PROBABILITIES`` + classical head
     - Obtain logits or arbitrary ranges with ``nn.Linear`` or deeper networks.
   * - Structured probability outputs
     - ``PROBABILITIES`` + ``LexGrouping`` / ``ModGrouping``
     - Preserves probability mass while reducing dimensionality.
   * - Hardware-friendly analytics
     - ``MODE_EXPECTATIONS`` (``no_bunching`` to taste)
     - Outputs one feature per mode, easy to interpret.
   * - Algorithm debugging
     - ``AMPLITUDES``
     - Complex amplitudes, simulation only.

Validation Tips
===============

- :class:`~merlin.measurement.mappers.Probabilities` automatically detects whether inputs are amplitudes or probabilities by checking the :math:`\ell_2` norm.
- :class:`~merlin.measurement.mappers.ModeExpectations` stores the marginalisation mask as a buffer, so it moves with the model across devices.
